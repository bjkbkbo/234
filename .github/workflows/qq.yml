name: q

on:
  push:
    paths:
      - ".github/workflows/qq.yml"
  workflow_dispatch:

jobs:
  run:
    runs-on: windows-latest
    timeout-minutes: 360

    env:
      # 占位：分卷下载基址（最终将拼成：${BASE_URL}/windows10.7z.001 ... .018）
      BASE_URL: "https://r2.kmoljklj.top/files/qemu/x64"
      PART_BASENAME: "windows10.7z"
      PART_FROM: "001"
      PART_TO: "018"

      # 解压后应得到的 qcow2 文件名
      QCOW2_FILE: "win10.qcow2"

      # QEMU VNC：display N => TCP 5900+N（例如 1 => 5901）
      VNC_DISPLAY: "1"
      VM_MEMORY_MB: "4096"

      # virtio ISO（下载到工作目录，供 QEMU 挂载）
      VIRTIO_ISO_URL: "https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.266-1/virtio-win-0.1.266.iso"
      VIRTIO_ISO_PATH: ".\\virtio-win-0.1.266.iso"

      # frp/frpc
      FRP_VERSION: "0.55.1"
      FRPC_INI_URL: "https://hk.kmoljklj.top/frpc/frpc.ini"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies (QEMU)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          # 安装 qemu（windows-latest 默认不保证存在）
          choco install -y qemu

          # 7z 在 runner 上一般可用；若你需要强制安装，可取消注释：
          # choco install -y 7zip

          # Chocolatey 的 qemu 包有时不会自动加入 PATH，因此这里做一次“定位 exe + 加入 PATH”。
          $qemuCmd = Get-Command qemu-system-x86_64.exe -ErrorAction SilentlyContinue

          if (-not $qemuCmd) {
            $candidateRoots = @(
              "C:\Program Files\qemu",
              "C:\Program Files (x86)\qemu",
              "C:\ProgramData\chocolatey\bin",
              "C:\ProgramData\chocolatey\lib"
            ) | Where-Object { Test-Path $_ }

            $qemuExe = $null
            foreach ($root in $candidateRoots) {
              $hit = Get-ChildItem -Path $root -Recurse -Filter "qemu-system-x86_64.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($hit) { $qemuExe = $hit.FullName; break }
            }

            if (-not $qemuExe) {
              throw "qemu-system-x86_64.exe not found after choco install. Check chocolatey logs."
            }

            $qemuDir = Split-Path -Parent $qemuExe
            Add-Content -Path $env:GITHUB_PATH -Value $qemuDir
            $qemuCmd = Get-Command $qemuExe
          }

          # 给后续 step 使用（避免依赖 PATH）
          "QEMU_EXE=$($qemuCmd.Source)" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

          & $qemuCmd.Source --version
          7z | Out-Null

      - name: Download Windows10 split 7z parts (+ sha256 verify) and virtio ISO (async)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          $baseUrl = "${env:BASE_URL}".TrimEnd("/")
          $baseName = $env:PART_BASENAME
          $from = [int]$env:PART_FROM
          $to = [int]$env:PART_TO

          function Get-ExpectedSha256FromFile([string]$shaFilePath) {
            $content = (Get-Content -Raw $shaFilePath).Trim()
            if ([string]::IsNullOrWhiteSpace($content)) { throw "Empty sha256 file: ${shaFilePath}" }

            # Common formats:
            # 1) "<hash>"
            # 2) "<hash> <filename>"
            # 3) "<hash> *<filename>"
            $token = ($content -split "\s+")[0].Trim()
            if ($token -notmatch "^[0-9a-fA-F]{64}$") { throw "Invalid sha256 in ${shaFilePath}: $token" }
            return $token.ToLowerInvariant()
          }

          # 组装下载任务（分卷 + 同名 sha256 + virtio iso）
          $downloads = @()

          for ($i = $from; $i -le $to; $i++) {
            $part = "{0:D3}" -f $i
            $fileName = "$baseName.$part"
            $shaFile = "$fileName.sha256"

            $downloads += [pscustomobject]@{ Url = "$baseUrl/$fileName"; Out = $fileName }
            $downloads += [pscustomobject]@{ Url = "$baseUrl/$shaFile"; Out = $shaFile }
          }

          $downloads += [pscustomobject]@{ Url = $env:VIRTIO_ISO_URL; Out = $env:VIRTIO_ISO_PATH }

          # 并发下载（PowerShell 7 支持 ForEach-Object -Parallel）
          # 说明：并发 + 大文件在 runner 上偶发会有某个 curl 直接 exit 1（瞬断/限流/HTTP2 bug 等）。
          # 这里采用“并发尝试 + 自动降级补齐（串行重试）”，保证整体稳定。
          $throttle = 3

          $parallelFailed = $false
          try {
            $downloads | ForEach-Object -Parallel {
              Set-StrictMode -Version Latest
              $ErrorActionPreference = "Stop"

              $u = $_.Url
              $o = $_.Out

              if (Test-Path $o) {
                Write-Host "Skip (exists): $o"
                return
              }

              $maxAttempts = 4
              for ($attempt = 1; $attempt -le $maxAttempts; $attempt++) {
                Write-Host "Downloading ($attempt/$maxAttempts) $u -> $o"

                # 外层循环兜底重试；--retry-all-errors 处理 5xx/网络抖动
                & curl.exe -fL -sS `
                  --retry 6 `
                  --retry-all-errors `
                  --retry-connrefused `
                  --retry-delay 2 `
                  --retry-max-time 0 `
                  -o $o `
                  $u

                if ($LASTEXITCODE -eq 0 -and (Test-Path $o)) {
                  break
                }

                if (Test-Path $o) { Remove-Item -Force $o -ErrorAction SilentlyContinue }
                Start-Sleep -Seconds ([Math]::Min(8, 2 * $attempt))
              }

              if (!(Test-Path $o)) {
                throw "Download failed after retries: $u -> $o"
              }
            } -ThrottleLimit $throttle
          } catch {
            Write-Host "WARNING: parallel download stage failed; will fallback to sequential for missing files."
            Write-Host $_
            $parallelFailed = $true
          }

          # Fallback：把缺失的文件串行补齐（即使并发阶段成功也做一次存在性检查）
          foreach ($d in $downloads) {
            $u = $d.Url
            $o = $d.Out

            if (Test-Path $o) { continue }

            $maxAttempts = 8
            for ($attempt = 1; $attempt -le $maxAttempts; $attempt++) {
              Write-Host "Fallback download ($attempt/$maxAttempts) $u -> $o"

              & curl.exe -fL -sS `
                --retry 10 `
                --retry-all-errors `
                --retry-connrefused `
                --retry-delay 2 `
                --retry-max-time 0 `
                -o $o `
                $u

              if ($LASTEXITCODE -eq 0 -and (Test-Path $o)) {
                break
              }

              if (Test-Path $o) { Remove-Item -Force $o -ErrorAction SilentlyContinue }
              Start-Sleep -Seconds ([Math]::Min(12, 2 * $attempt))
            }

            if (!(Test-Path $o)) {
              throw "Fallback download still failed: $u -> $o"
            }
          }

          if ($parallelFailed) {
            Write-Host "Parallel stage had failures, but all files were recovered by fallback."
          }

          # 校验每个分卷
          for ($i = $from; $i -le $to; $i++) {
            $part = "{0:D3}" -f $i
            $fileName = "$baseName.$part"
            $shaFile = "$fileName.sha256"

            if (!(Test-Path $fileName)) { throw "Missing part: $fileName" }
            if (!(Test-Path $shaFile)) { throw "Missing sha256: $shaFile" }

            $expected = Get-ExpectedSha256FromFile $shaFile
            $actual = (Get-FileHash -Algorithm SHA256 $fileName).Hash.ToLowerInvariant()

            if ($actual -ne $expected) {
              throw "SHA256 mismatch for $fileName. expected=$expected actual=$actual"
            }

            Write-Host "SHA256 OK: $fileName"
          }

          if (!(Test-Path $env:VIRTIO_ISO_PATH)) {
            throw "virtio iso missing: $($env:VIRTIO_ISO_PATH)"
          }

          Write-Host "Downloaded and verified parts:"
          Get-ChildItem "$baseName.*" | Sort-Object Name | Select-Object -ExpandProperty Name
          Write-Host "virtio iso: $($env:VIRTIO_ISO_PATH)"

      - name: Extract win10.qcow2 (from .001)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          $firstPart = "$($env:PART_BASENAME).001"
          if (!(Test-Path $firstPart)) {
            throw "Missing $firstPart"
          }

          # 7z 会自动读取后续分卷 .002 .003 ...
          7z x -y $firstPart

          if (!(Test-Path $env:QCOW2_FILE)) {
            Write-Host "Workspace after extraction:"
            Get-ChildItem -Force
            throw "Expected qcow2 not found: $($env:QCOW2_FILE)"
          }

      - name: Download frpc (windows_amd64)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          $ver = $env:FRP_VERSION
          $zip = "frp_${ver}_windows_amd64.zip"
          $url = "https://github.com/fatedier/frp/releases/download/v${ver}/${zip}"

          curl.exe -fL --retry 3 --retry-all-errors -o $zip $url
          7z x -y $zip | Out-Null

          $dir = "frp_${ver}_windows_amd64"
          if (!(Test-Path $dir)) { throw "Missing extracted directory: $dir" }

          Copy-Item "$dir\\frpc.exe" ".\\frpc.exe" -Force
          .\\frpc.exe -v

      - name: Fetch frpc.ini (placeholder supported)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          $url = $env:FRPC_INI_URL
          $ok = $true

          try {
            curl.exe -fL --retry 3 --retry-all-errors -o frpc.ini $url
          } catch {
            $ok = $false
          }

          if (-not $ok) {
            Write-Host "WARNING: Failed to download frpc.ini from: $url"

            # 用数组逐行写入，避免 YAML block scalar + PowerShell here-string 造成解析错误
            $lines = @(
              "[common]",
              "server_addr = 127.0.0.1",
              "server_port = 7000",
              "",
              "# 示例：把本机 VNC 5901 暴露出去（按你的 frps 配置修改）",
              "[vnc]",
              "type = tcp",
              "local_ip = 127.0.0.1",
              "local_port = 5901",
              "remote_port = 5901"
            )
            $lines | Set-Content -Encoding ASCII frpc.ini
          } else {
            Write-Host "Downloaded frpc.ini from: $url"
          }

          Write-Host "---- frpc.ini ----"
          Get-Content frpc.ini | Select-Object -First 200

      - name: Start frpc in background
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          # 注意：RedirectStandardOutput 与 RedirectStandardError 不能指向同一个文件
          Start-Process `
            -FilePath ".\\frpc.exe" `
            -ArgumentList "-c", ".\\frpc.ini" `
            -NoNewWindow `
            -RedirectStandardOutput "frpc.out.log" `
            -RedirectStandardError "frpc.err.log"

          Start-Sleep -Seconds 2
          $p = Get-Process frpc -ErrorAction SilentlyContinue
          if (-not $p) {
            Write-Host "frpc failed to start"
            if (Test-Path frpc.out.log) { Get-Content frpc.out.log -Tail 200 }
            if (Test-Path frpc.err.log) { Get-Content frpc.err.log -Tail 200 }
            exit 1
          }

          Write-Host "frpc started (pid=$($p.Id))."
          if (Test-Path frpc.out.log) { Get-Content frpc.out.log -Tail 50 }
          if (Test-Path frpc.err.log) { Get-Content frpc.err.log -Tail 50 }

      - name: Run QEMU with VNC (foreground)
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          $qcow2 = $env:QCOW2_FILE
          $vncDisplay = [int]$env:VNC_DISPLAY
          $mem = $env:VM_MEMORY_MB
          $smp = [Environment]::ProcessorCount

          $virtioIso = $env:VIRTIO_ISO_PATH
          if (!(Test-Path $virtioIso)) {
            throw "virtio iso not found: $virtioIso"
          }
          $virtioIso = (Resolve-Path $virtioIso).Path

          # 说明：
          # - GitHub Hosted Runner 不保证支持/启用 WHPX；但按你的要求保留 -accel whpx
          # - VNC: 0.0.0.0:<display> => tcp 5900+display（例 display=1 => 5901）
          #
          # 这里把你给的命令尽量原样搬过来（其中 install drive 未指定文件，仍按“占位”保留）
          $args = @(
            "-accel", "whpx",
            "-cpu", "Westmere",
            "-smp", "$smp",
            "-machine", "q35,mem-merge=off",
            "-m", "$mem",
            "-drive", "file=$qcow2,format=qcow2,if=ide,cache=writeback",
            "-device", "qemu-xhci",
            "-device", "usb-kbd",
            "-device", "usb-tablet",
            # 原命令里有：-device usb-storage,drive=install
            # 但没有提供对应的：-drive if=none,id=install,file=...
            # 会导致 QEMU 报错 “can't find value 'install'”，因此先移除该占位项。
            "-drive", "if=none,id=virtio,format=raw,media=cdrom,file=$virtioIso",
            "-device", "usb-storage,drive=virtio",
            "-net", "nic",
            "-net", "user",
            "-display", "none",
            "-vnc", "0.0.0.0:$vncDisplay"
          )

          Write-Host "Starting QEMU:"
          Write-Host "qemu-system-x86_64 $($args -join ' ')"
          Write-Host "VNC TCP port should be: $((5900 + $vncDisplay))"

          $qemuExe = $env:QEMU_EXE
          if ([string]::IsNullOrWhiteSpace($qemuExe) -or !(Test-Path $qemuExe)) {
            # 兜底：如果环境变量没写入成功，尝试直接解析
            $qemuExe = (Get-Command qemu-system-x86_64.exe -ErrorAction Stop).Source
          }

          & $qemuExe @args
